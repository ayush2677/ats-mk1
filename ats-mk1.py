# -*- coding: utf-8 -*-
"""Trading_AI_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13gnvmVWAX-0hlF9rztK_vw52T2sadqdL
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

import os
import yfinance as yf
import pandas as pd
import csv

# Define the currency pair
pair = 'USDINR=X'  # or 'USD/INR'

# Define the paths to the source and target CSV files
source_csv_file = r'C:\Users\HP\OneDrive\Desktop\ATS\ATS-mk1\usd_inr_updated_data.csv'
target_csv_file = r'C:\Users\HP\OneDrive\Desktop\ATS\ATS-mk1\usd_inr_historical_data.csv'

# Function to show the last 5 entries from the CSV file
def show_last_5_entries(csv_file):
    try:
        with open(csv_file, 'r') as file:
            lines = file.readlines()
            last_5_entries = lines[-5:]
            for entry in last_5_entries:
                print(entry.strip())
    except FileNotFoundError:
        print(f"File not found: {csv_file}")
    except Exception as e:
        print(f"An error occurred: {e}")

# Show the last 5 entries from the target CSV file
show_last_5_entries(target_csv_file)

# Ask if the user wants to update the data
update_data = input("Do you want to update the data? (yes/no): ").lower()

# Check for security level before updating
if update_data == 'yes':
    security_level = input("To confirm, type 'YES' (in uppercase): ")

    if security_level == 'YES':
        # Prompt for starting and ending dates
        start_date = input("Enter the starting date (YYYY-MM-DD): ")
        end_date = input("Enter the ending date (YYYY-MM-DD): ")

        # Download historical data
        data = yf.download(pair, start=start_date, end=end_date)

        # Save data to a CSV file
        data.to_csv(source_csv_file)

        # Check if the data to be appended is already present in the target file
        with open(target_csv_file, 'r') as target_file:
            target_data = target_file.read()

        with open(source_csv_file, 'r') as source_file:
            source_data = source_file.read()

        if source_data not in target_data:
            # Open the source CSV file for reading
            with open(source_csv_file, 'r', newline='') as source_file:
                source_reader = csv.reader(source_file)
                next(source_reader)  # Skip the header row if it exists

                # Open the target CSV file for appending
                with open(target_csv_file, 'a', newline='') as target_file:
                    target_writer = csv.writer(target_file)

                    # Iterate through the rows in the source file and append them to the target file
                    for row in source_reader:
                        target_writer.writerow(row)

            print("Entries appended successfully.")
        else:
            print("Data already exists in the target file. No changes made.")
    else:
        print("Update aborted. Security level verification failed.")
else:
    print("Move to the next code.")


# Load and preprocess data
data = pd.read_csv(r'C:\Users\HP\OneDrive\Desktop\ATS\ATS-mk1\usd_inr_historical_data.csv', index_col='Date', parse_dates=True)
data = data[['Close']]

# Normalize data
scaler = MinMaxScaler(feature_range=(0, 1))
data_scaled = scaler.fit_transform(data)

# Convert time series data to supervised learning
def create_dataset(dataset, time_steps=1):
    X, y = [], []
    for i in range(len(dataset) - time_steps + 1):
        X.append(dataset[i:(i + time_steps), 0])
        y.append(dataset[i + time_steps - 1, 0])
    return np.array(X), np.array(y)

# Function to generate predictions for future time steps
def generate_future_predictions(model, last_data, future_steps):
    last_data_scaled = scaler.transform(last_data)
    last_data_scaled = np.reshape(last_data_scaled, (1, len(last_data_scaled), 1))

    future_predictions = []
    for _ in range(future_steps):
        next_step = model.predict(last_data_scaled)
        future_predictions.append(next_step[0, 0])

        last_data_scaled = np.reshape(last_data_scaled, (1, last_data_scaled.shape[1], 1))
        last_data_scaled = np.append(last_data_scaled[:, 1:, :], np.reshape(next_step, (1, 1, 1)), axis=1)

    future_predictions = scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1))
    return future_predictions

model_updation = input("Model is going to update on new data, do you want? (yes/no): ")

if model_updation.lower() in ["yes", "y"]:
    # Build and train the model (assuming it's the first time)
    time_steps = 10
    X, y = create_dataset(data_scaled, time_steps)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    model = Sequential()
    model.add(LSTM(units=50, return_sequences=True, input_shape=(X.shape[1], 1)))
    model.add(LSTM(units=50))
    model.add(Dense(units=1))
    model.compile(optimizer='adam', loss='mean_squared_error')

    model.fit(X, y, epochs=100, batch_size=32)

    print("Model trained on historical data.")

    # Make predictions for the last time steps
    test_data = data_scaled[-time_steps:]
    test_data = np.reshape(test_data, (1, time_steps, 1))
    predicted_price = model.predict(test_data)
    predicted_price = scaler.inverse_transform(predicted_price)

    print("Predicted Price:", predicted_price)

    choice = input("For monthly predictions: 1\nFor weekly predictions: 2\nFor both: 3\nEnter your choice: ")

    if choice == "1":
        future_predictions = generate_future_predictions(model, data[-time_steps:], 5)
        print("Future Predictions (monthly):", future_predictions)
        print("Thanks for using ATS-mk1.")

    elif choice == "2":
        updated_data = pd.read_csv(r'C:\Users\HP\OneDrive\Desktop\ATS\ATS-mk1\usd_inr_updated_data.csv', index_col='Date', parse_dates=True)
        updated_data = updated_data[['Close']]
        future_predictions = generate_future_predictions(model, updated_data[-time_steps:], 5)
        print("Future Predictions (weekly):", future_predictions)
        print("Thanks for using ATS-mk1.")

    elif choice == "3":
        future_predictions_monthly = generate_future_predictions(model, data[-time_steps:], 5)
        future_predictions_weekly = generate_future_predictions(model, updated_data[-time_steps:], 5)

        print("Future Predictions (monthly):", future_predictions_monthly)
        print("Future Predictions (weekly):", future_predictions_weekly)
        print("Thanks for using ATS-mk1.")

    else:
        print("Invalid choice. Thanks for using ATS-mk1.")

else:
    print("Thanks for using ATS-mk1.")

